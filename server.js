// –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–∑ .env —Ñ–∞–π–ª–∞
require('dotenv').config();

const http = require('http');
const fs = require('fs');
const path = require('path');
const url = require('url');

// –ù–æ–≤—ã–π unified database interface
const { createDatabase } = require('./src/database');

const PORT = 3001;

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –µ–¥–∏–Ω–æ–π –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
let db;
try {
    db = createDatabase();
    console.log('üóÑÔ∏è  Unified database interface initialized');
} catch (error) {
    console.error('‚ùå Database initialization failed:', error);
    process.exit(1);
}

const server = http.createServer((req, res) => {
    const parsedUrl = url.parse(req.url, true);
    const pathname = parsedUrl.pathname;
    
    // –î–æ–±–∞–≤–ª—è–µ–º CORS –∑–∞–≥–æ–ª–æ–≤–∫–∏
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
        res.writeHead(200);
        res.end();
        return;
    }
    
    try {
        if (pathname === '/') {
            // –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–æ–¥—É–ª—å–Ω—É—é –≤–µ—Ä—Å–∏—é
            const modularPath = path.join(__dirname, 'public', 'modular-index.html');
            const legacyPath = path.join(__dirname, 'public', 'index.html');
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –º–æ–¥—É–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è
            if (fs.existsSync(modularPath)) {
                const content = fs.readFileSync(modularPath, 'utf8');
                res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
                res.end(content);
            } else if (fs.existsSync(legacyPath)) {
                const content = fs.readFileSync(legacyPath, 'utf8');
                res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
                res.end(content);
            } else {
                res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
                res.end(`
                    <!DOCTYPE html>
                    <html>
                    <head><title>Task Manager</title><meta charset="utf-8"></head>
                    <body>
                        <h1>üöÄ Task Manager Server</h1>
                        <p>–°–µ—Ä–≤–µ—Ä —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}</p>
                        <p>–í—Ä–µ–º—è: ${new Date().toLocaleString('ru-RU')}</p>
                        <ul>
                            <li><a href="/api/health">Health Check</a></li>
                            <li><a href="/api/tasks">Tasks API</a></li>
                            <li><a href="/api/stats">Stats API</a></li>
                            <li><a href="/legacy">Legacy –≤–µ—Ä—Å–∏—è</a></li>
                        </ul>
                    </body>
                    </html>
                `);
            }
        } else if (pathname === '/legacy') {
            // Legacy –≤–µ—Ä—Å–∏—è - —Å—Ç–∞—Ä—ã–π index.html
            const legacyPath = path.join(__dirname, 'public', 'index.html');
            if (fs.existsSync(legacyPath)) {
                const content = fs.readFileSync(legacyPath, 'utf8');
                res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
                res.end(content);
            } else {
                res.writeHead(404, { 'Content-Type': 'text/plain' });
                res.end('Legacy version not found');
            }
        } else if (pathname === '/api/health') {
            // Health check
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
                status: 'ok',
                timestamp: new Date().toISOString(),
                port: PORT,
                uptime: process.uptime()
            }));
        } else if (pathname === '/api/tasks') {
            // –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –∑–∞–¥–∞—á
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify([
                { id: 1, title: '–¢–µ—Å—Ç–æ–≤–∞—è –∑–∞–¥–∞—á–∞', status: 'pending', assignee: 'test_user' }
            ]));
        } else if (pathname === '/api/stats') {
            // –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
                total: 1,
                completed: 0,
                pending: 1
            }));
        } else if (pathname === '/api/telegram/start-polling' && req.method === 'POST') {
            // API –¥–ª—è –∑–∞–ø—É—Å–∫–∞ polling –±–æ—Ç–∞
            (async () => {
                try {
                    const botToken = await db.getSetting('bot_token');
                    if (!botToken) {
                        res.writeHead(400, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify({ error: 'Bot token not configured' }));
                        return;
                    }
                    
                    // –ó–∞–ø—É—Å–∫–∞–µ–º polling
                    startBotPolling(botToken, db);
                    
                    res.writeHead(200, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({ 
                        success: true, 
                        message: 'Bot polling started. Users can now send /start to register.' 
                    }));
                } catch (error) {
                    res.writeHead(500, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({ error: error.message }));
                }
            })();
            return;
        } else if (pathname === '/api/admin/users') {
            // API –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–∑ —Ä–∞–±–æ—á–µ–≥–æ —á–∞—Ç–∞
            (async () => {
                try {
                    // –ü–æ–ª—É—á–∞–µ–º work_chat_id –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫
                    const workChatId = await db.getSetting('work_chat_id');
                    
                    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
                    const users = await db.getAllUsersWithRoles();
                    
                    if (!workChatId) {
                        // –ï—Å–ª–∏ —á–∞—Ç ID –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
                        res.writeHead(200, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify(users || []));
                    } else {
                        // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
                        const activatedUsers = [];
                        
                        for (const user of users) {
                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–ª –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –±–æ—Ç–∞
                            const isActivated = await db.getSetting(`user_activated_${user.user_id}`);
                            
                            if (isActivated) {
                                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ—Å—Ç–æ–∏—Ç –ª–∏ –≤ —á–∞—Ç–µ
                                const botToken = await db.getSetting('bot_token');
                                if (botToken) {
                                    const isMember = await checkChatMembership(user.user_id, workChatId, botToken);
                                    if (isMember) {
                                        activatedUsers.push({
                                            ...user,
                                            chat_id: workChatId,
                                            is_from_configured_chat: true,
                                            is_activated: true
                                        });
                                    }
                                }
                            }
                        }
                        
                        res.writeHead(200, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify(activatedUsers));
                    }
                } catch (error) {
                    console.error('Users API error:', error);
                    res.writeHead(500, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({ error: 'Failed to fetch users' }));
                }
            })();
        } else if (pathname === '/api/settings') {
            // API –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫
            (async () => {
                try {
                    const settings = await db.getAllSettings();
                    res.writeHead(200, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify(settings));
                } catch (error) {
                    console.error('Settings API error:', error);
                    res.writeHead(500, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({ error: 'Failed to fetch settings' }));
                }
            })();
        } else if (pathname.startsWith('/api/settings/') && req.method === 'PUT') {
            // API –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
            const settingKey = pathname.split('/api/settings/')[1];
            
            let body = '';
            req.on('data', chunk => {
                body += chunk.toString();
            });
            
            req.on('end', async () => {
                try {
                    const { value } = JSON.parse(body);
                    
                    await db.setSetting(settingKey, value, '');
                    
                    res.writeHead(200, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({ 
                        success: true, 
                        message: 'Setting saved successfully',
                        key: settingKey,
                        value: value
                    }));
                } catch (error) {
                    console.error('Setting save error:', error);
                    if (error.message.includes('JSON')) {
                        res.writeHead(400, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify({ error: 'Invalid JSON data' }));
                    } else {
                        res.writeHead(500, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify({ error: 'Failed to save setting' }));
                    }
                }
            });
            return; // –í–∞–∂–Ω–æ: –≤—ã—Ö–æ–¥–∏–º –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏, —á—Ç–æ–±—ã –Ω–µ –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É
        } else if (pathname === '/api/admin/users/refresh' && req.method === 'POST') {
            // API –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–∑ Telegram —á–∞—Ç–∞
            (async () => {
                try {
                    // –ü–æ–ª—É—á–∞–µ–º work_chat_id –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫
                    const workChatId = await db.getSetting('work_chat_id');
                    if (!workChatId) {
                        res.writeHead(400, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify({ error: 'Chat ID not configured' }));
                        return;
                    }
                    
                    try {
                        // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω –±–æ—Ç–∞ –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –∏–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
                        let botToken = await db.getSetting('bot_token');
                        
                        if (!botToken) {
                            botToken = process.env.BOT_TOKEN;
                        }
                        
                        if (!botToken) {
                            res.writeHead(400, { 'Content-Type': 'application/json' });
                            res.end(JSON.stringify({ error: 'Bot token not configured' }));
                            return;
                        }
                        
                        // –ü–æ–ª—É—á–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —á–∞—Ç–∞
                        const https = require('https');
                        const chatMembersUrl = `https://api.telegram.org/bot${botToken}/getChatMembersCount?chat_id=${workChatId}`;
                        
                        https.get(chatMembersUrl, (telegramRes) => {
                            let data = '';
                            telegramRes.on('data', chunk => data += chunk);
                            telegramRes.on('end', async () => {
                                try {
                                    const membersCount = JSON.parse(data);
                                    
                                    if (!membersCount.ok) {
                                        throw new Error(membersCount.description || 'Failed to get chat members count');
                                    }
                                    
                                    console.log(`Chat ${workChatId} has ${membersCount.result} members`);
                                    
                                    // –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–∑ –±–∞–∑—ã –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –∏—Ö —Å—Ç–∞—Ç—É—Å
                                    try {
                                        const users = await db.getAllUsersWithRoles();
                                        
                                        // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –≤ —á–∞—Ç–µ
                                        const filteredUsers = [];
                                        const botToken = await db.getSetting('bot_token');
                                        
                                        for (const user of users) {
                                            const isActivated = await db.getSetting(`user_activated_${user.user_id}`);
                                            
                                            if (isActivated && botToken) {
                                                const isMember = await checkChatMembership(user.user_id, workChatId, botToken);
                                                if (isMember) {
                                                    filteredUsers.push({
                                                        ...user,
                                                        chat_id: workChatId,
                                                        is_from_configured_chat: true,
                                                        is_activated: true
                                                    });
                                                }
                                            }
                                        }
                                        
                                        res.writeHead(200, { 'Content-Type': 'application/json' });
                                        res.end(JSON.stringify({
                                            success: true,
                                            message: `–û–±–Ω–æ–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–∑ —á–∞—Ç–∞`,
                                            users: filteredUsers,
                                            chat_id: workChatId,
                                            total_chat_members: membersCount.result,
                                            users_in_db: filteredUsers.length,
                                            timestamp: new Date().toISOString()
                                        }));
                                    } catch (dbError) {
                                        console.error('Database error:', dbError);
                                        res.writeHead(500, { 'Content-Type': 'application/json' });
                                        res.end(JSON.stringify({ error: 'Database error' }));
                                    }
                                } catch (parseError) {
                                    console.error('Telegram API parse error:', parseError);
                                    res.writeHead(500, { 'Content-Type': 'application/json' });
                                    res.end(JSON.stringify({ error: 'Failed to parse Telegram response' }));
                                    db.close();
                                }
                            });
                        }).on('error', async (telegramError) => {
                            console.error('Telegram API error:', telegramError);
                            // Fallback: –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–∑ –±–∞–∑—ã
                            try {
                                const users = await db.getAllUsersWithRoles();
                                res.writeHead(200, { 'Content-Type': 'application/json' });
                                res.end(JSON.stringify({
                                    success: true,
                                    message: 'Users list refreshed (offline mode)',
                                    users: users,
                                    chat_id: workChatId,
                                    warning: 'Could not fetch live chat data',
                                    timestamp: new Date().toISOString()
                                }));
                            } catch (dbError) {
                                console.error('Database error:', dbError);
                                res.writeHead(500, { 'Content-Type': 'application/json' });
                                res.end(JSON.stringify({ error: 'Database error' }));
                            }
                        });
                    } catch (error) {
                        console.error('Refresh error:', error);
                        res.writeHead(500, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify({ error: 'Failed to refresh users' }));
                    }
                } catch (error) {
                    console.error('Refresh API error:', error);
                    res.writeHead(500, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({ error: 'Failed to refresh users list' }));
                }
            })();
            return;
        } else if (pathname === '/api/admin/chat/info' && req.method === 'GET') {
            // API –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —á–∞—Ç–µ
            (async () => {
                try {
                    const workChatId = await db.getSetting('work_chat_id');
                    if (!workChatId) {
                        res.writeHead(400, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify({ error: 'Chat ID not configured' }));
                        return;
                    }
                    
                    // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω –±–æ—Ç–∞ –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –∏–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
                    let botToken = await db.getSetting('bot_token');
                    
                    if (!botToken) {
                        botToken = process.env.BOT_TOKEN;
                    }
                    
                    if (!botToken) {
                        res.writeHead(400, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify({ error: 'Bot token not configured' }));
                        return;
                    }
                    
                    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —á–∞—Ç–µ
                    const https = require('https');
                    const chatInfoUrl = `https://api.telegram.org/bot${botToken}/getChat?chat_id=${workChatId}`;
                    
                    https.get(chatInfoUrl, (telegramRes) => {
                        let data = '';
                        telegramRes.on('data', chunk => data += chunk);
                        telegramRes.on('end', () => {
                            try {
                                const chatInfo = JSON.parse(data);
                                
                                if (!chatInfo.ok) {
                                    throw new Error(chatInfo.description || 'Failed to get chat info');
                                }
                                
                                // –ü–æ–ª—É—á–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
                                const membersCountUrl = `https://api.telegram.org/bot${botToken}/getChatMembersCount?chat_id=${workChatId}`;
                                
                                https.get(membersCountUrl, (membersRes) => {
                                    let membersData = '';
                                    membersRes.on('data', chunk => membersData += chunk);
                                    membersRes.on('end', () => {
                                        try {
                                            const membersCount = JSON.parse(membersData);
                                            
                                            res.writeHead(200, { 'Content-Type': 'application/json' });
                                            res.end(JSON.stringify({
                                                success: true,
                                                chat: {
                                                    id: chatInfo.result.id,
                                                    title: chatInfo.result.title,
                                                    type: chatInfo.result.type,
                                                    description: chatInfo.result.description,
                                                    members_count: membersCount.ok ? membersCount.result : 'unknown'
                                                }
                                            }));
                                        } catch (parseError) {
                                            res.writeHead(200, { 'Content-Type': 'application/json' });
                                            res.end(JSON.stringify({
                                                success: true,
                                                chat: {
                                                    id: chatInfo.result.id,
                                                    title: chatInfo.result.title,
                                                    type: chatInfo.result.type,
                                                    description: chatInfo.result.description,
                                                    members_count: 'unknown'
                                                }
                                            }));
                                        }
                                    });
                                }).on('error', () => {
                                    res.writeHead(200, { 'Content-Type': 'application/json' });
                                    res.end(JSON.stringify({
                                        success: true,
                                        chat: {
                                            id: chatInfo.result.id,
                                            title: chatInfo.result.title,
                                            type: chatInfo.result.type,
                                            description: chatInfo.result.description,
                                            members_count: 'unknown'
                                        }
                                    }));
                                });
                            } catch (parseError) {
                                console.error('Chat info parse error:', parseError);
                                res.writeHead(500, { 'Content-Type': 'application/json' });
                                res.end(JSON.stringify({ error: 'Failed to parse chat info' }));
                            }
                        });
                    }).on('error', (telegramError) => {
                        console.error('Telegram chat info error:', telegramError);
                        res.writeHead(500, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify({ error: 'Failed to get chat info' }));
                    });
                } catch (error) {
                    console.error('Chat info API error:', error);
                    res.writeHead(500, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({ error: 'Failed to get chat information' }));
                }
            })();
            return;
        } else if ((pathname === '/api/bot/status' || pathname === '/api/admin/bot/status') && req.method === 'GET') {
            // API –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ –±–æ—Ç–∞
            (async () => {
                try {
                    // –°–Ω–∞—á–∞–ª–∞ –ø—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å —Ç–æ–∫–µ–Ω –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫
                    let botToken = await db.getSetting('bot_token');
                    
                    // –ï—Å–ª–∏ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –Ω–µ—Ç —Ç–æ–∫–µ–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è
                    if (!botToken) {
                        botToken = process.env.BOT_TOKEN;
                    }
                    
                    if (!botToken) {
                        res.writeHead(200, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify({ 
                            isRunning: false,
                            hasToken: false,
                            botInfo: 'Bot token not configured',
                            status: 'offline'
                        }));
                        return;
                    }
                    
                    try {
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–æ—Ç–∞ —á–µ—Ä–µ–∑ Telegram API
                        const https = require('https');
                        const botInfoUrl = `https://api.telegram.org/bot${botToken}/getMe`;
                        
                        https.get(botInfoUrl, (telegramRes) => {
                            let data = '';
                            telegramRes.on('data', chunk => data += chunk);
                            telegramRes.on('end', () => {
                                try {
                                    const botInfo = JSON.parse(data);
                                    
                                    if (botInfo.ok && botInfo.result) {
                                        res.writeHead(200, { 'Content-Type': 'application/json' });
                                        res.end(JSON.stringify({
                                            isRunning: true,
                                            hasToken: true,
                                            botInfo: `Bot @${botInfo.result.username} (${botInfo.result.first_name})`,
                                            status: 'online',
                                            botData: {
                                                id: botInfo.result.id,
                                                username: botInfo.result.username,
                                                first_name: botInfo.result.first_name,
                                                can_join_groups: botInfo.result.can_join_groups,
                                                can_read_all_group_messages: botInfo.result.can_read_all_group_messages
                                            }
                                        }));
                                    } else {
                                        res.writeHead(200, { 'Content-Type': 'application/json' });
                                        res.end(JSON.stringify({
                                            isRunning: false,
                                            hasToken: true,
                                            botInfo: 'Bot token is invalid',
                                            status: 'error',
                                            error: botInfo.description || 'Invalid token'
                                        }));
                                    }
                                } catch (parseError) {
                                    res.writeHead(200, { 'Content-Type': 'application/json' });
                                    res.end(JSON.stringify({
                                        isRunning: false,
                                        hasToken: true,
                                        botInfo: 'Failed to parse bot response',
                                        status: 'error',
                                        error: parseError.message
                                    }));
                                }
                            });
                        }).on('error', (telegramError) => {
                            res.writeHead(200, { 'Content-Type': 'application/json' });
                            res.end(JSON.stringify({
                                isRunning: false,
                                hasToken: true,
                                botInfo: 'Failed to connect to Telegram API',
                                status: 'error',
                                error: telegramError.message
                            }));
                        });
                    } catch (error) {
                        res.writeHead(500, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify({
                            isRunning: false,
                            hasToken: true,
                            botInfo: 'Bot status check failed',
                            status: 'error',
                            error: error.message
                        }));
                    }
                } catch (dbError) {
                    console.error('Database error in bot status:', dbError);
                    res.writeHead(500, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({
                        isRunning: false,
                        hasToken: false,
                        botInfo: 'Database error',
                        status: 'error',
                        error: dbError.message
                    }));
                }
            })();
            return;
        } else if ((pathname === '/api/bot/token' || pathname === '/api/admin/bot/token') && req.method === 'POST') {
            // API –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞ –±–æ—Ç–∞
            let body = '';
            req.on('data', chunk => {
                body += chunk.toString();
            });
            
            req.on('end', async () => {
                try {
                    const { token } = JSON.parse(body);
                    
                    if (!token) {
                        res.writeHead(400, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify({ error: 'Token is required' }));
                        return;
                    }
                    
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–∫–µ–Ω –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
                    await db.setSetting('bot_token', token, 'Telegram Bot Token');
                    
                    res.writeHead(200, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({ 
                        success: true, 
                        message: 'Bot token saved successfully' 
                    }));
                } catch (error) {
                    console.error('Bot token save error:', error);
                    res.writeHead(500, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({ error: 'Failed to save bot token' }));
                }
            });
            return;
        } else if ((pathname === '/api/bot/stop' || pathname === '/api/admin/bot/stop') && req.method === 'POST') {
            // API –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –±–æ—Ç–∞
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ 
                success: true, 
                message: 'Bot stopped (simulation - no actual bot process running)' 
            }));
            return;
        } else if ((pathname === '/api/bot/test' || pathname === '/api/admin/bot/test') && req.method === 'POST') {
            // API –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
            (async () => {
                try {
                    // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω –±–æ—Ç–∞ –∏ ID —á–∞—Ç–∞
                    const botTokenSetting = await db.getSetting('bot_token');
                    let botToken = botTokenSetting ? botTokenSetting.value : null;
                    
                    if (!botToken) {
                        botToken = process.env.BOT_TOKEN;
                    }
                    
                    const workChatSetting = await db.getSetting('work_chat_id');
                    const workChatId = workChatSetting ? workChatSetting.value : null;
                    
                    if (!botToken || !workChatId) {
                        res.writeHead(400, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify({ error: 'Bot token or chat ID not configured' }));
                        return;
                    }
                    
                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                    const https = require('https');
                    const testMessage = `üîî –¢–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç Task Manager\\n\\n–í—Ä–µ–º—è: ${new Date().toLocaleString('ru-RU')}\\n–°—Ç–∞—Ç—É—Å: –°–∏—Å—Ç–µ–º–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ!`;
                    
                    const postData = JSON.stringify({
                        chat_id: workChatId,
                        text: testMessage,
                        parse_mode: 'Markdown'
                    });
                    
                    const options = {
                        hostname: 'api.telegram.org',
                        path: `/bot${botToken}/sendMessage`,
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Content-Length': Buffer.byteLength(postData)
                        }
                    };
                    
                    const req = https.request(options, (telegramRes) => {
                        let data = '';
                        telegramRes.on('data', chunk => data += chunk);
                        telegramRes.on('end', () => {
                            try {
                                const result = JSON.parse(data);
                                if (result.ok) {
                                    res.writeHead(200, { 'Content-Type': 'application/json' });
                                    res.end(JSON.stringify({ 
                                        success: true, 
                                        message: 'Test notification sent successfully',
                                        messageId: result.result.message_id
                                    }));
                                } else {
                                    res.writeHead(400, { 'Content-Type': 'application/json' });
                                    res.end(JSON.stringify({ 
                                        error: 'Failed to send test message',
                                        details: result.description 
                                    }));
                                }
                            } catch (parseError) {
                                res.writeHead(500, { 'Content-Type': 'application/json' });
                                res.end(JSON.stringify({ error: 'Failed to parse Telegram response' }));
                            }
                        });
                    });
                    
                    req.on('error', (error) => {
                        res.writeHead(500, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify({ error: 'Failed to send test notification' }));
                    });
                    
                    req.write(postData);
                    req.end();
                    
                } catch (error) {
                    console.error('Test notification error:', error);
                    res.writeHead(500, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({ error: 'Failed to send test notification' }));
                }
            })();
            return;
        } else if (pathname.startsWith('/css/') || pathname.startsWith('/js/') || pathname.startsWith('/public/') || pathname.match(/\.(css|js|png|jpg|ico)$/)) {
            // –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–∞–π–ª—ã
            let filePath;
            if (pathname.startsWith('/css/') || pathname.startsWith('/js/')) {
                filePath = path.join(__dirname, 'public', pathname);
            } else {
                filePath = path.join(__dirname, 'public', pathname.replace('/public/', ''));
            }
            if (fs.existsSync(filePath)) {
                const ext = path.extname(filePath);
                const contentType = {
                    '.css': 'text/css',
                    '.js': 'application/javascript',
                    '.png': 'image/png',
                    '.jpg': 'image/jpeg',
                    '.ico': 'image/x-icon'
                }[ext] || 'text/plain';
                
                const content = fs.readFileSync(filePath);
                res.writeHead(200, { 'Content-Type': contentType });
                res.end(content);
            } else {
                res.writeHead(404, { 'Content-Type': 'text/plain' });
                res.end('File not found');
            }
        } else {
            // 404
            res.writeHead(404, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: 'Not found' }));
        }
    } catch (error) {
        console.error('Request error:', error);
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Internal server error' }));
    }
});

// –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è polling
let pollingInterval = null;
let lastUpdateId = 0;

// –§—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ polling –±–æ—Ç–∞
function startBotPolling(botToken, db) {
    if (pollingInterval) {
        clearInterval(pollingInterval);
    }
    
    console.log('ü§ñ Starting bot polling...');
    
    pollingInterval = setInterval(async () => {
        try {
            await pollTelegramUpdates(botToken, db);
        } catch (error) {
            console.error('Polling error:', error);
        }
    }, 2000); // –û–ø—Ä–∞—à–∏–≤–∞–µ–º –∫–∞–∂–¥—ã–µ 2 —Å–µ–∫—É–Ω–¥—ã
}

// –§—É–Ω–∫—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –æ—Ç Telegram
async function pollTelegramUpdates(botToken, db) {
    const https = require('https');
    const url = `https://api.telegram.org/bot${botToken}/getUpdates?offset=${lastUpdateId + 1}&timeout=1`;
    
    return new Promise((resolve) => {
        https.get(url, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', async () => {
                try {
                    const response = JSON.parse(data);
                    if (response.ok && response.result.length > 0) {
                        for (const update of response.result) {
                            await handleUpdate(update, botToken, db);
                            lastUpdateId = update.update_id;
                        }
                    }
                    resolve();
                } catch (error) {
                    console.error('Error parsing updates:', error);
                    resolve();
                }
            });
        }).on('error', (error) => {
            console.error('Error getting updates:', error);
            resolve();
        });
    });
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
async function handleUpdate(update, botToken, db) {
    if (update.message && update.message.text) {
        const message = update.message;
        
        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–æ–º–∞–Ω–¥—É /start
        if (message.text === '/start') {
            await handleStartCommand(message, botToken, db);
        }
    }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /start
async function handleStartCommand(message, botToken, db) {
    try {
        const user = message.from;
        const workChatId = await db.getSetting('work_chat_id');
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        await db.addUser(
            user.id.toString(),
            user.username || null,
            user.first_name || '',
            user.last_name || null
        );
        
        // –ü–æ–º–µ—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∫–∞–∫ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —á–µ—Ä–µ–∑ –±–æ—Ç–∞
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        await db.setSetting(`user_activated_${user.id}`, 'true', 'User activated via bot');
        
        console.log(`User registered: ${user.first_name} (@${user.username || 'no_username'})`);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ—Å—Ç–æ–∏—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ —Ä–∞–±–æ—á–µ–º —á–∞—Ç–µ
        if (workChatId) {
            const isMember = await checkChatMembership(user.id, workChatId, botToken);
            if (isMember) {
                await sendMessage(botToken, user.id, 
                    '‚úÖ –û—Ç–ª–∏—á–Ω–æ! –í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ —Å–∏—Å—Ç–µ–º–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∞–º–∏.\n\n' +
                    '–í—ã —è–≤–ª—è–µ—Ç–µ—Å—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–º —Ä–∞–±–æ—á–µ–≥–æ —á–∞—Ç–∞ –∏ –º–æ–∂–µ—Ç–µ –ø–æ–ª—É—á–∞—Ç—å –∑–∞–¥–∞—á–∏.');
            } else {
                await sendMessage(botToken, user.id, 
                    '‚ö†Ô∏è –í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã, –Ω–æ –Ω–µ —Å–æ—Å—Ç–æ–∏—Ç–µ –≤ —Ä–∞–±–æ—á–µ–º —á–∞—Ç–µ.\n\n' +
                    '–ü–æ–ø—Ä–æ—Å–∏—Ç–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –¥–æ–±–∞–≤–∏—Ç—å –≤–∞—Å –≤ —Ä–∞–±–æ—á–∏–π —á–∞—Ç –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∑–∞–¥–∞—á.');
            }
        } else {
            await sendMessage(botToken, user.id, 
                '‚úÖ –í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ —Å–∏—Å—Ç–µ–º–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∞–º–∏!');
        }
        
    } catch (error) {
        console.error('Error handling /start command:', error);
    }
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —á–ª–µ–Ω—Å—Ç–≤–∞ –≤ —á–∞—Ç–µ
async function checkChatMembership(userId, chatId, botToken) {
    const https = require('https');
    const url = `https://api.telegram.org/bot${botToken}/getChatMember?chat_id=${chatId}&user_id=${userId}`;
    
    return new Promise((resolve) => {
        https.get(url, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                try {
                    const response = JSON.parse(data);
                    if (response.ok) {
                        const status = response.result.status;
                        // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å—á–∏—Ç–∞–µ—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–º –µ—Å–ª–∏ –æ–Ω –Ω–µ –ø–æ–∫–∏–Ω—É–ª —á–∞—Ç –∏ –Ω–µ –∑–∞–±–∞–Ω–µ–Ω
                        resolve(['creator', 'administrator', 'member', 'restricted'].includes(status));
                    } else {
                        resolve(false);
                    }
                } catch (error) {
                    resolve(false);
                }
            });
        }).on('error', () => resolve(false));
    });
}

// –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
async function sendMessage(botToken, chatId, text) {
    const https = require('https');
    const postData = JSON.stringify({
        chat_id: chatId,
        text: text
    });
    
    const options = {
        hostname: 'api.telegram.org',
        path: `/bot${botToken}/sendMessage`,
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Content-Length': Buffer.byteLength(postData)
        }
    };
    
    return new Promise((resolve) => {
        const req = https.request(options, (res) => {
            resolve();
        });
        req.on('error', () => resolve());
        req.write(postData);
        req.end();
    });
}

server.listen(PORT, '127.0.0.1', () => {
    console.log(`üöÄ Minimal server running on http://127.0.0.1:${PORT}`);
    console.log(`üìä Health: http://127.0.0.1:${PORT}/api/health`);
});

server.on('error', (err) => {
    console.error('Server error:', err);
});