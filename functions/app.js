const functions = require('firebase-functions');
const express = require('express');
const cors = require('cors');
const TaskBot = require('../bot');
const { getAllTasks, getTaskStats, completeTask, deleteTask, updateTask, submitForReview, approveTask, requestRevision, returnToWork } = require('../database-firestore');

const app = express();

// Firebase config
const config = functions.config() || {};

// Middleware
app.use(cors({
    origin: ['https://pro-telegram.web.app', 'https://pro-telegram.firebaseapp.com', 'http://localhost:3000'],
    credentials: true
}));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
app.use((req, res, next) => {
    console.log(`üì• ${req.method} ${req.url} - ${new Date().toISOString()}`);
    console.log('üîß UPDATED VERSION - Fixed auth issues');
    next();
});

// –£–±—Ä–∞–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
let bot;
let botToken = config.bot?.token;

function initBot(token) {
    if (bot) {
        try {
            console.log('Stopping existing bot instance...');
            bot.bot.stopPolling();
            bot = null;
            setTimeout(() => {}, 1000);
        } catch (error) {
            console.warn('Error stopping previous bot:', error);
        }
    }
    
    try {
        console.log('Starting new bot instance...');
        bot = new TaskBot(token);
        botToken = token;
        console.log('‚úÖ Telegram bot started successfully');
        return true;
    } catch (error) {
        console.error('‚ùå Error starting bot:', error);
        return false;
    }
}

if (botToken) {
    const initResult = initBot(botToken);
    console.log('Bot initialization result:', initResult);
} else {
    console.warn('BOT_TOKEN not provided. Add it in settings to start the bot.');
    console.warn('Bot notifications will not work until token is set.');
}

// –£–±—Ä–∞–Ω—ã –≤—Å–µ —Ä–æ—É—Ç—ã –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏

// API –º–∞—Ä—à—Ä—É—Ç—ã
app.get('/api/tasks', async (req, res) => {
    try {
        const tasks = await getAllTasks();
        res.json(tasks);
    } catch (error) {
        console.error('Error fetching tasks:', error);
        res.status(500).json({ error: 'Failed to fetch tasks' });
    }
});

app.get('/api/stats', async (req, res) => {
    try {
        const stats = await getTaskStats();
        res.json(stats);
    } catch (error) {
        console.error('Error fetching stats:', error);
        res.status(500).json({ error: 'Failed to fetch stats' });
    }
});

app.put('/api/tasks/:id/complete', async (req, res) => {
    try {
        const taskId = req.params.id;
        const result = await completeTask(taskId);
        
        if (result > 0) {
            res.json({ success: true, message: 'Task completed successfully' });
        } else {
            res.status(404).json({ error: 'Task not found' });
        }
    } catch (error) {
        console.error('Error completing task:', error);
        res.status(500).json({ error: 'Failed to complete task' });
    }
});

app.put('/api/tasks/:id', async (req, res) => {
    try {
        const taskId = req.params.id;
        const { title, description, deadline } = req.body;
        
        if (!title || !deadline) {
            return res.status(400).json({ error: 'Title and deadline are required' });
        }
        
        const result = await updateTask(taskId, title, description, deadline);
        
        if (result > 0) {
            res.json({ success: true, message: 'Task updated successfully' });
        } else {
            res.status(404).json({ error: 'Task not found' });
        }
    } catch (error) {
        console.error('Error updating task:', error);
        res.status(500).json({ error: 'Failed to update task' });
    }
});

app.delete('/api/tasks/:id', async (req, res) => {
    try {
        const taskId = req.params.id;
        const result = await deleteTask(taskId);
        
        if (result > 0) {
            res.json({ success: true, message: 'Task deleted successfully' });
        } else {
            res.status(404).json({ error: 'Task not found' });
        }
    } catch (error) {
        console.error('Error deleting task:', error);
        res.status(500).json({ error: 'Failed to delete task' });
    }
});

app.put('/api/tasks/:id/submit', async (req, res) => {
    try {
        const taskId = req.params.id;
        const { userId } = req.body;
        const result = await submitForReview(taskId, userId);
        
        if (result > 0) {
            res.json({ success: true, message: 'Task submitted for review' });
        } else {
            res.status(404).json({ error: 'Task not found or already submitted' });
        }
    } catch (error) {
        console.error('Error submitting task:', error);
        res.status(500).json({ error: 'Failed to submit task' });
    }
});

app.put('/api/tasks/:id/approve', async (req, res) => {
    try {
        const taskId = req.params.id;
        const { reviewerId, comment } = req.body;
        const result = await approveTask(taskId, reviewerId, comment);
        
        if (result.changes > 0) {
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–∑–¥—Ä–∞–≤–∏—Ç–µ–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ Telegram
            if (bot && result.task) {
                const timeSpent = result.task.time_spent_minutes || 0;
                const efficiency = result.task.efficiency_score ? Math.round(result.task.efficiency_score * 100) : 100;
                const points = Math.round(result.task.efficiency_score || 1);
                
                let congratsMessage = `üéâ –û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞, ${result.task.assignee_username}!

üìã –ó–∞–¥–∞—á–∞ "${result.task.title}" —É—Å–ø–µ—à–Ω–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞!

‚è±Ô∏è –í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: ${timeSpent} –º–∏–Ω—É—Ç
üìä –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å: ${efficiency}%
üíé –ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ –±–∞–ª–ª–æ–≤: ${points}`;

                try {
                    await bot.bot.sendMessage(result.task.chat_id, congratsMessage);
                    console.log(`Approval notification sent for task ${taskId} to chat ${result.task.chat_id}`);
                } catch (telegramError) {
                    console.error('Error sending Telegram message:', telegramError);
                }
            }
            
            res.json({ success: true, message: 'Task approved and points awarded' });
        } else {
            res.status(404).json({ error: 'Task not found' });
        }
    } catch (error) {
        console.error('Error approving task:', error);
        res.status(500).json({ error: 'Failed to approve task' });
    }
});

app.put('/api/tasks/:id/revision', async (req, res) => {
    try {
        const taskId = req.params.id;
        const { reviewerId, comment } = req.body;
        
        // –ü–æ–ª—É—á–∞–µ–º –∑–∞–¥–∞—á—É –ü–ï–†–ï–î –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è chat_id
        const tasks = await getAllTasks();
        const originalTask = tasks.find(t => t.id == taskId);
        
        if (!originalTask) {
            return res.status(404).json({ error: 'Task not found' });
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–∞–¥–∞—á–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞
        if (originalTask.status !== 'review' && originalTask.status !== 'completed') {
            return res.status(400).json({ error: `Task cannot be rejected. Current status: ${originalTask.status}. Only tasks with status 'review' can be rejected.` });
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏
        const result = await requestRevision(taskId, reviewerId, comment);
        
        if (result > 0) {
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–∏ –≤ Telegram
            if (bot && originalTask.chat_id) {
                try {
                    const rejisionCount = (originalTask.revision_count || 0) + 1;
                    const rejectionMessage = `üîÑ –ó–∞–¥–∞—á–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞ –Ω–∞ –¥–æ—Ä–∞–±–æ—Ç–∫—É

üìã –ó–∞–¥–∞—á–∞: ${originalTask.title}
üë§ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: ${originalTask.assignee_username}
üí¨ –ü—Ä–∏—á–∏–Ω–∞: ${comment}

–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ—Ä–∞–±–æ—Ç–æ–∫: ${rejisionCount}

‚ö†Ô∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–Ω–µ—Å–∏—Ç–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∑–∞–¥–∞—á—É –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É —Å–Ω–æ–≤–∞.`;

                    const keyboard = {
                        inline_keyboard: [[
                            { text: 'üîÑ –í–∑—è—Ç—å –≤ —Ä–∞–±–æ—Ç—É', callback_data: `return_${taskId}` }
                        ]]
                    };

                    await bot.bot.sendMessage(originalTask.chat_id, rejectionMessage, {
                        reply_markup: keyboard
                    });
                } catch (telegramError) {
                    console.error('Error sending rejection notification:', telegramError);
                }
            }
            
            res.json({ success: true, message: 'Task sent for revision and notification sent' });
        } else {
            res.status(404).json({ error: 'Task not found or not updated' });
        }
    } catch (error) {
        console.error('Error in revision endpoint:', error);
        res.status(500).json({ error: 'Failed to request revision' });
    }
});

app.put('/api/tasks/:id/return', async (req, res) => {
    try {
        const taskId = req.params.id;
        const result = await returnToWork(taskId);
        
        if (result > 0) {
            res.json({ success: true, message: 'Task returned to work' });
        } else {
            res.status(404).json({ error: 'Task not found' });
        }
    } catch (error) {
        console.error('Error returning task to work:', error);
        res.status(500).json({ error: 'Failed to return task to work' });
    }
});

// –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–æ—Ç–∞
app.get('/api/bot/status', (req, res) => {
    res.json({ 
        isRunning: !!bot,
        hasToken: !!botToken,
        botInfo: bot ? 'Bot initialized' : 'Bot not initialized'
    });
});

app.post('/api/bot/token', (req, res) => {
    const { token } = req.body;
    
    if (!token) {
        return res.status(400).json({ error: 'Token is required' });
    }
    
    console.log('Attempting to initialize bot with new token...');
    const success = initBot(token);
    console.log('Bot initialization result:', success);
    
    if (success) {
        console.log('Bot successfully started and ready for notifications');
        res.json({ success: true, message: 'Bot started successfully' });
    } else {
        console.error('Failed to initialize bot with provided token');
        res.status(400).json({ error: 'Failed to start bot. Check token validity.' });
    }
});

app.post('/api/bot/stop', (req, res) => {
    if (bot) {
        bot.bot.stopPolling();
        bot = null;
        res.json({ success: true, message: 'Bot stopped' });
    } else {
        res.json({ success: true, message: 'Bot was not running' });
    }
});

// –£–±—Ä–∞–Ω—ã API –¥–ª—è —Ä–µ–π—Ç–∏–Ω–≥–∞ –∏ –¥–µ—Ç–∞–ª—å–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏

// –£–±—Ä–∞–Ω—ã API –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π

// –£–±—Ä–∞–Ω—ã API –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–æ–ª—è–º–∏ –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏

// 404 handler
app.use('*', (req, res) => {
    res.status(404).json({ error: 'Route not found' });
});

// Error handler
app.use((error, req, res, next) => {
    console.error('Unhandled error:', error);
    res.status(500).json({ error: 'Internal server error' });
});

module.exports = app;